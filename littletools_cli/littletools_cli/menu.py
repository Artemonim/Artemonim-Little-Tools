#!/usr/bin/env python3
# -*- coding: utf-8 -*-


"""
    --- AUTO-GENERATED DOCSTRING ---
    This docstring is automatically generated by Agent Docstrings.
    Do not modify this block directly.

    Classes/Functions:
      - Functions:
        - _load_single_plugin(entry_point: importlib.metadata.EntryPoint, failed_plugins: List[str]) -> Optional[Tuple[str, typer.Typer, str]] (line 26)
        - _get_package_description(dist_name: str) -> str (line 55)
        - get_command_plugins() -> Tuple[Dict[str, typer.Typer], Dict[str, str], Dict[str, str]] (line 70)
        - post_execution_dialog() -> str (line 120)
        - _get_click_commands(tool_app: typer.Typer) -> Tuple[List[click.Command], bool] (line 152)
        - show_tool_menu(tool_name: str, tool_app: typer.Typer) -> Optional[str] (line 170)
        - main() -> None (line 252)
    --- END AUTO-GENERATED DOCSTRING ---
LittleTools CLI - Interactive Menu

This script provides an interactive menu to run tools in the LittleTools project.
It discovers and loads all 'tool' plugins that are installed in the environment.
"""

import importlib.metadata
import time
from collections import defaultdict
from typing import Dict
from typing import List
from typing import Optional
from typing import Tuple

import click
import typer
from rich.console import Console

# * Configuration
COMMANDS_GROUP = "littletools.commands"
console = Console()


def _load_single_plugin(
    entry_point: importlib.metadata.EntryPoint, failed_plugins: List[str]
) -> Optional[Tuple[str, typer.Typer, str]]:
    """Load a single plugin from an entry point.

    Args:
        entry_point: The entry point to load
        failed_plugins: List to append error messages to

    Returns:
        Tuple of (plugin_name, plugin_app, dist_name) if successful, None otherwise
    """
    try:
        plugin_app = entry_point.load()
        if not isinstance(plugin_app, typer.Typer):
            failed_plugins.append(f"'{entry_point.name}': Not a Typer app")
            return None

        # * Determine the parent distribution name in a version-agnostic way
        dist_name_opt: Optional[str]
        if hasattr(entry_point, "dist") and entry_point.dist:  # Python 3.11+
            dist_name_opt = entry_point.dist.name
        else:
            # * Fallback: derive from the dotted path before the first dot
            dist_name_opt = entry_point.value.split(":", 1)[0].split(".")[0]

        # * Ensure we have a non-None, hashable key for our dicts
        dist_name: str = dist_name_opt or "unknown-package"

        return entry_point.name, plugin_app, dist_name

    except Exception as exc:  # pylint: disable=broad-except
        failed_plugins.append(f"'{entry_point.name}': {type(exc).__name__}: {str(exc)}")
        return None


def _get_package_description(dist_name: str) -> str:
    """Get package description from metadata.

    Args:
        dist_name: Name of the distribution package

    Returns:
        Package summary/description or empty string if not found
    """
    try:
        dist_metadata = importlib.metadata.metadata(dist_name)
        # * Use bracket notation for PackageMetadata access
        return dist_metadata["Summary"] or ""
    except (importlib.metadata.PackageNotFoundError, KeyError):
        return ""


def get_command_plugins() -> (
    Tuple[Dict[str, typer.Typer], Dict[str, str], Dict[str, str]]
):
    """Discovers command plugins and maps them to their parent packages.

    Returns:
        plugins: Mapping *command name ➜ Typer app*.
        plugin_packages: Mapping *command name ➜ distribution / package name*.
        package_descriptions: Mapping *package name ➜ one-line description* pulled
            from the package's metadata (``Summary`` field) if available.
    """
    plugins: Dict[str, typer.Typer] = {}
    plugin_packages: Dict[str, str] = {}
    package_descriptions: Dict[str, str] = {}
    failed_plugins: List[str] = []  # * Collect errors for optional debug view

    try:
        eps = importlib.metadata.entry_points()
        if hasattr(eps, "select"):
            entry_points = eps.select(group=COMMANDS_GROUP)
        else:
            entry_points = eps.get(COMMANDS_GROUP, [])  # type: ignore[arg-type]

        for entry_point in entry_points:
            plugin_result = _load_single_plugin(entry_point, failed_plugins)
            if plugin_result is None:
                continue

            plugin_name, plugin_app, dist_name = plugin_result
            plugins[plugin_name] = plugin_app
            plugin_packages[plugin_name] = dist_name

            # * Cache distribution summary (description) on first encounter
            if dist_name not in package_descriptions:
                package_descriptions[dist_name] = _get_package_description(dist_name)

        # * Show failed plugins info if at least one plugin failed to load
        if failed_plugins:
            console.print(
                f"[yellow]! Debug: Failed to load {len(failed_plugins)} plugin(s):[/yellow]"
            )
            for failure in failed_plugins:
                console.print(f"  - {failure}")
            console.print("  Press any key to continue...")
            try:
                import msvcrt

                msvcrt.getch()  # Windows
            except ImportError:
                input()  # Unix/Linux

    except Exception as err:  # pylint: disable=broad-except
        console.print(f"[red]! Error discovering plugins: {err}[/red]")

    return plugins, plugin_packages, package_descriptions


def post_execution_dialog() -> str:
    """
    Displays a menu after a command has run to decide the next action.
    Returns:
        The user's choice: 'tool_menu', 'main_menu', or 'exit'.
    """
    console.print("\n---")
    console.print("[bold]What would you like to do next?[/bold]")
    console.print("  [green]1[/green]. Return to the current tool's menu")
    console.print("  [green]2[/green]. Return to the main menu")
    console.print("  [green]0[/green]. Exit LittleTools")

    while True:
        try:
            choice = typer.prompt("Your choice", default="1")
            if choice == "1":
                return "tool_menu"
            elif choice == "2":
                return "main_menu"
            elif choice == "0":
                return "exit"
            else:
                console.print(
                    f"[red]! Invalid choice '{choice}'. Please try again.[/red]"
                )
        except (typer.Abort, KeyboardInterrupt, EOFError):
            return "exit"


def _get_click_commands(tool_app: typer.Typer) -> Tuple[List[click.Command], bool]:
    """Extract Click commands from a Typer app.

    Args:
        tool_app: The Typer application

    Returns:
        Tuple of (commands_list, is_group_flag)
    """
    # Convert the Typer app to a Click Command/Group to reliably access its commands
    click_cmd = typer.main.get_command(tool_app)

    # Determine if this is a multi-command group or a single command.
    # * In Typer ≥0.9 root apps with only one subcommand may be returned as
    #   TyperCommand (click.Command) without the ``commands`` attribute.
    is_group = hasattr(click_cmd, "commands") and bool(
        getattr(click_cmd, "commands", {})
    )

    if is_group:
        # * Use getattr with type ignore to safely access commands
        commands_dict = getattr(click_cmd, "commands", {})
        commands = list(commands_dict.values())
    else:
        # Treat the whole Typer app as a single command.
        commands = [click_cmd]

    return commands, is_group


def show_tool_menu(  # noqa: C901
    tool_name: str, tool_app: typer.Typer
) -> Optional[str]:
    """Displays the menu for a specific tool group."""
    commands, is_group = _get_click_commands(tool_app)

    should_continue = True
    while should_continue:
        console.clear()
        console.print(
            f"\n[bold underline]Tool: {tool_app.info.name or tool_name}[/bold underline]"
        )
        if tool_app.info.help:
            console.print(f"  [dim]{tool_app.info.help}[/dim]")

        console.print("\n[bold]Available Commands:[/bold]")

        for i, command in enumerate(commands, 1):
            help_text = (
                getattr(command, "help", None)
                or tool_app.info.help
                or "No description."
            )
            cmd_name = getattr(command, "name", tool_name)
            console.print(
                f"  [green]{i:2d}[/green]. [bold]{cmd_name}[/bold] - {help_text}"
            )

        console.print("\n  [bold]0[/bold]. Back to Main Menu")

        try:
            choice = input("\nEnter your choice: ").strip()
            if choice == "0":
                break

            choice_idx = int(choice)
            if 1 <= choice_idx <= len(commands):
                selected_command = commands[choice_idx - 1]

                # --- EXECUTION LOGIC ---
                console.clear()
                launch_cmd_name = getattr(selected_command, "name", tool_name)
                console.print(
                    f"\n> Launching command: [bold cyan]{tool_name} {launch_cmd_name}[/bold cyan]"
                )
                console.print("-" * 40)
                try:
                    # Invoke the selected command. For single-command apps invoke without subcommand name.
                    if is_group:
                        tool_app([selected_command.name])
                    else:
                        tool_app([])  # Runs the root Typer command directly
                except SystemExit as e:
                    # A non-zero exit code usually indicates an error or user cancellation.
                    if e.code is not None and e.code != 0:
                        console.print(
                            f"[yellow]! Command exited with code {e.code}.[/yellow]"
                        )
                except Exception as e:
                    console.print(
                        f"[bold red]! An unexpected error occurred while running command '{launch_cmd_name}':[/bold red]"
                    )
                    console.print(e)

                console.print("-" * 40)

                next_action = post_execution_dialog()
                if next_action == "exit":
                    # Propagate the exit signal up
                    return "exit"
                elif next_action == "main_menu":
                    should_continue = False  # Will exit the loop and return to main()
                # if 'tool_menu', just continue the loop
            else:
                console.print(
                    f"[red]! Invalid choice '{choice}'. Please try again.[/red]"
                )
                time.sleep(1.5)

        except ValueError:
            console.print("[red]! Invalid input. Please enter a number.[/red]")
            time.sleep(1.5)
        except (KeyboardInterrupt, EOFError):
            break
    # Implicitly return 'main_menu' when the loop is broken
    return "main_menu"


def main() -> None:
    """Main function to run the interactive menu."""
    command_plugins, plugin_packages, package_descriptions = get_command_plugins()

    if not command_plugins:
        console.print("[yellow]! Warning: No LittleTools plugins found.[/yellow]")
        console.print(
            "  This usually means you haven't installed any tool packages yet."
        )
        console.print("  Run the 'start.ps1' script to install all tools,")
        console.print(
            "  or install one manually (e.g., 'pip install ./littletools-video')."
        )
        return

    while True:
        console.clear()
        console.print("\n[bold cyan]=== LittleTools Interactive Menu ===[/bold cyan]")
        console.print("Select a tool group to see its commands:")

        # * Group tools by their parent package for a cleaner UX
        package_to_tools: Dict[str, List[str]] = defaultdict(list)
        for tool_name, pkg_name in plugin_packages.items():
            package_to_tools[pkg_name].append(tool_name)

        # * Build a flat index so the user can still input a single number
        index_to_tool: Dict[int, str] = {}
        current_index = 1

        for pkg_name in sorted(package_to_tools.keys()):
            header = f"[bold underline]{pkg_name}[/bold underline]"
            description = package_descriptions.get(pkg_name, "")
            console.print(f"\n{header}")
            if description:
                console.print(f"  [dim]{description}[/dim]")

            for tool in sorted(package_to_tools[pkg_name]):
                help_text = (
                    command_plugins[tool].info.help or "No description available."
                )
                console.print(
                    f"  [green]{current_index:2d}[/green]. [bold]{tool}[/bold] - {help_text}"
                )
                index_to_tool[current_index] = tool
                current_index += 1

        console.print("\n  [bold]0[/bold]. Exit")

        try:
            choice = input("\nEnter your choice: ").strip()
            if choice == "0":
                console.print("Goodbye!")
                break

            choice_idx = int(choice)
            if choice_idx in index_to_tool:
                selected_name = index_to_tool[choice_idx]
                selected_app = command_plugins[selected_name]
                # The tool menu can now signal that we need to exit the program
                if show_tool_menu(selected_name, selected_app) == "exit":
                    break
            else:
                console.print(
                    f"[red]! Invalid choice '{choice}'. Please try again.[/red]"
                )
                time.sleep(1.5)

        except ValueError:
            console.print("[red]! Invalid input. Please enter a number.[/red]")
            time.sleep(1.5)
        except (KeyboardInterrupt, EOFError):
            console.print("\nGoodbye!")
            break


if __name__ == "__main__":
    main()
