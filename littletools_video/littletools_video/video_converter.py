#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
    --- AUTO-GENERATED DOCSTRING ---
    This docstring is automatically generated by Agent Docstrings.
    Do not modify this block directly.

    Classes/Functions:
      - Functions:
        - single() -> None (line 286)
        - tree() -> None (line 478)
    --- END AUTO-GENERATED DOCSTRING ---
Video Converter Tool

A Typer-based CLI tool for converting and merging videos using FFmpeg with NVENC hardware acceleration.
This script is designed to be a plugin for the 'littletools-cli'.
"""

import asyncio
import os
import shutil
import subprocess
import time
from pathlib import Path
from typing import Any
from typing import Coroutine
from typing import Dict
from typing import List
from typing import Optional

import typer
from rich.console import Console
from typing_extensions import Annotated

from littletools_core.utils import BatchTimeEstimator
from littletools_core.utils import ensure_dir_exists
from littletools_core.utils import format_duration
from littletools_core.utils import prompt_for_interactive_settings
from littletools_core.utils import run_tasks_with_semaphore
from littletools_core.utils import safe_delete
from littletools_core.utils import setup_signal_handler
from littletools_video.ffmpeg_utils import ProcessingStats
from littletools_video.ffmpeg_utils import get_nvenc_video_options
from littletools_video.ffmpeg_utils import get_video_duration
from littletools_video.ffmpeg_utils import get_video_resolution
from littletools_video.ffmpeg_utils import run_ffmpeg_command

# * Create a Typer application for this specific tool
app = typer.Typer(
    name="video-converter",
    help="Convert, transcode, and merge videos using FFmpeg (NVENC).",
    no_args_is_help=True,
)
console = Console()

# * Default input and output directories relative to a potential project root
# * The user can override these with CLI options.
INPUT_DIR = Path.cwd() / "0-INPUT-0"
OUTPUT_DIR = Path.cwd() / "0-OUTPUT-0"


async def _process_single_file_for_conversion(
    file_path: Path,
    output_dir: Path,
    quality: str,
    fps: str,
    resolution: str,
    normalize_audio: bool,
    overwrite: bool,
    codec: str,
    stats: ProcessingStats,
    estimator: BatchTimeEstimator,
    position: int,
    total: int,
    use_original_name: bool = False,
) -> None:
    """Helper to process one file asynchronously."""
    # Determine output filename: use original name or add suffix
    output_filename = (
        file_path.name if use_original_name else f"{file_path.stem}_converted.mp4"
    )
    output_path = output_dir / output_filename

    eta_str = estimator.get_eta_str()
    console.print(
        f"[{position}/{total}] {file_path.name} (CQ: {quality}, FPS: {fps}, Res: {resolution}) | ETA: {eta_str}"
    )

    if not overwrite and output_path.exists():
        stats.increment("skipped")
        console.print(f"  -> Skipped (exists): {output_path.name}")
        return

    total_duration = await get_video_duration(str(file_path))

    filters: List[str] = []
    if resolution != "original":
        res_map = {"480p": 480, "720p": 720, "1080p": 1080, "2160p": 2160}
        target_height = res_map.get(resolution)
        if target_height:
            original_res = await get_video_resolution(str(file_path))
            if original_res and original_res[1] > target_height:
                filters.append(f"scale=-2:{target_height}:flags=lanczos")
    # * If quality is 'Compressed' (40) AND no specific resolution was chosen,
    # * apply the legacy 720p scaling behavior.
    elif quality == "40":
        filters.append(
            "scale='if(gt(iw,ih),-2,720)':'if(gt(iw,ih),720,-2)',flags=lanczos"
        )

    if fps != "original":
        filters.append(f"fps={fps}")

    # * For H.264, force 8-bit pixel format to avoid errors with 10-bit sources on consumer GPUs.
    if codec == "h264":
        filters.append("format=yuv420p")

    video_cmd = get_nvenc_video_options(codec=codec, quality=quality)
    if filters:
        video_cmd.extend(["-vf", ",".join(filters)])

    audio_cmd = (
        ["-c:a", "aac", "-b:a", "192k", "-af", "loudnorm=I=-16:TP=-3:LRA=11"]
        if normalize_audio
        else ["-c:a", "copy"]
    )

    cmd = (
        ["ffmpeg", "-y", "-i", str(file_path)]
        + video_cmd
        + audio_cmd
        + [str(output_path)]
    )

    success = await run_ffmpeg_command(
        cmd,
        stats=stats,
        quiet=True,
        output_path=str(output_path),
        file_position=position,
        file_count=total,
        filename=file_path.name,
        total_duration=total_duration,
    )
    if success:
        # * Calculate size delta between input and output
        input_size = file_path.stat().st_size
        output_size = output_path.stat().st_size
        # * Record cumulative size statistics
        stats.stats["bytes_in"] += input_size
        stats.stats["bytes_out"] += output_size
        delta = output_size - input_size
        delta_mb = delta / (1024 * 1024)
        sign = "+" if delta > 0 else ""
        console.print(
            f"  [green]✓ Success:[/green] {output_path.name} (Δ {sign}{delta_mb:.2f} MB)"
        )
        if total_duration:
            estimator.update(total_duration)
    else:
        console.print(
            f"  [red]✗ Failed:[/red] {file_path.name}. Check logs for details."
        )
        if output_path.exists():
            safe_delete(output_path)


@app.command()
def convert(
    input_dir: Annotated[
        Path, typer.Option("--input", "-i", help="Input directory containing videos.")
    ] = INPUT_DIR,
    output_dir: Annotated[
        Path,
        typer.Option("--output", "-o", help="Output directory for converted videos."),
    ] = OUTPUT_DIR,
    quality: Annotated[
        str, typer.Option(help="Encoding quality (CQ value). [26|30|34|40]")
    ] = "26",
    fps: Annotated[
        str, typer.Option(help="Target FPS. [original|30|60|120]")
    ] = "original",
    resolution: Annotated[
        str,
        typer.Option(
            help="Target resolution (scales down only). [original|480p|720p|1080p|2160p]"
        ),
    ] = "original",
    codec: Annotated[
        str, typer.Option(help="Video codec for encoding. [hevc|h264]")
    ] = "hevc",
    normalize_audio: Annotated[
        bool, typer.Option(help="Normalize audio to -16 LUFS.")
    ] = False,
    overwrite: Annotated[
        bool, typer.Option(help="Overwrite existing files in the output directory.")
    ] = False,
    concurrency: Annotated[
        int, typer.Option(help="Number of files to process concurrently.")
    ] = 2,
) -> None:
    """
    Batch convert videos in a directory to HEVC (H.265) or H.264.
    """
    console.print(
        f"[*] Starting batch conversion from '{input_dir}' to '{output_dir}'."
    )
    ensure_dir_exists(input_dir)
    ensure_dir_exists(output_dir)

    supported_extensions = [".mp4", ".mkv", ".mov", ".avi", ".webm"]
    files_to_process = [
        p for p in input_dir.iterdir() if p.suffix.lower() in supported_extensions
    ]

    if not files_to_process:
        console.print(
            "[yellow]! No supported video files found in the input directory.[/yellow]"
        )
        raise typer.Exit()

    console.print(f"[*] Found {len(files_to_process)} video(s) to process.")

    stats = ProcessingStats()
    stats.stats["total"] = len(files_to_process)
    estimator = BatchTimeEstimator()
    stop_event = asyncio.Event()
    start_time = time.monotonic()  # ! Track start time for interruption statistics

    async def main_async_logic() -> float:
        logic_start_time = time.time()
        console.print("[*] Calculating total video duration for ETA...")
        for file_path in files_to_process:
            duration = await get_video_duration(str(file_path))
            if duration:
                estimator.add_item(duration)

        if estimator.total_workload > 0:
            console.print(
                f"[*] Total video duration: {format_duration(estimator.total_workload)}"
            )

        estimator.start()

        tasks = [
            _process_single_file_for_conversion(
                file,
                output_dir,
                quality,
                fps,
                resolution,
                normalize_audio,
                overwrite,
                codec,
                stats,
                estimator,
                i + 1,
                len(files_to_process),
                use_original_name=False,
            )
            for i, file in enumerate(files_to_process)
        ]

        await run_tasks_with_semaphore(tasks, stop_event, concurrency)
        return time.time() - logic_start_time

    total_elapsed_time = 0.0
    try:
        total_elapsed_time = asyncio.run(main_async_logic())
    except KeyboardInterrupt:
        console.print(
            "\n[yellow]! User interrupted the process. Shutting down...[/yellow]"
        )
        stop_event.set()
        # ! Show statistics before termination
        elapsed_time = time.monotonic() - start_time
        console.print("\n--- Interrupted Process Summary ---")
        stats.print_summary(elapsed_time)
    except asyncio.CancelledError:
        console.print("\n[yellow]! Process was cancelled. Shutting down...[/yellow]")
        stop_event.set()
        # ! Show statistics before termination
        elapsed_time = time.monotonic() - start_time
        console.print("\n--- Cancelled Process Summary ---")
        stats.print_summary(elapsed_time)

    console.print("\n--- Conversion Summary ---")
    stats.print_summary(total_elapsed_time)
    console.print("[green]✓ Conversion process completed.[/green]")


@app.command()
def single() -> None:  # noqa: C901
    """
    Convert a single video file or all supported files in a directory with interactive prompts for all options.
    """
    console.print("[*] Interactive single file or folder conversion.")

    try:
        # --- Input File or Directory ---
        while True:
            input_str = typer.prompt(
                "Enter the path to the input video file or directory"
            )
            input_path = Path(input_str.strip().strip('"'))
            if input_path.exists():
                break
            console.print(
                f"[red]! File or directory not found: {input_path}. Please try again.[/red]"
            )

        # --- Determine files to process ---
        supported_extensions = [".mp4", ".mkv", ".mov", ".avi", ".webm"]
        if input_path.is_file():
            files_to_process = [input_path]
        elif input_path.is_dir():
            files_to_process = [
                p
                for p in input_path.iterdir()
                if p.suffix.lower() in supported_extensions and p.is_file()
            ]
            if not files_to_process:
                console.print(
                    "[yellow]! No supported video files found in the directory.[/yellow]"
                )
                raise typer.Exit()
        else:
            console.print(
                f"[red]! Path is neither a file nor a directory: {input_path}.[/red]"
            )
            raise typer.Exit()

        # --- Output File or Directory ---
        if len(files_to_process) == 1:
            default_output_name = f"{files_to_process[0].stem}_converted.mp4"
            output_str = typer.prompt(
                "Enter the output file path (or press Enter for default)",
                default=str(OUTPUT_DIR / default_output_name),
            )
            output_file = Path(output_str.strip().strip('"'))
            output_dir = output_file.parent  # Define output_dir for single file
            ensure_dir_exists(output_file.parent)
        else:
            output_str = typer.prompt(
                "Enter the output directory for converted files (or press Enter for default)",
                default=str(OUTPUT_DIR),
            )
            output_file = None
            output_dir = Path(output_str.strip().strip('"'))
            ensure_dir_exists(output_dir)

        # --- Interactive Settings Menu ---
        initial_settings = {
            "quality": "26",
            "fps": "original",
            "resolution": "original",
            "codec": "hevc",
            "normalize_audio": False,
            "overwrite": False,
        }

        settings_definitions: List[Dict[str, Any]] = [
            {
                "key": "quality",
                "label": "Quality",
                "type": "choice",
                "choices": {
                    "Master (CQ=26)": "26",
                    "Optimal (CQ=30)": "30",
                    "Compact (CQ=34)": "34",
                    "Compressed (CQ=40, <=720p)": "40",
                },
            },
            {
                "key": "fps",
                "label": "FPS",
                "type": "choice",
                "choices": {
                    "Original": "original",
                    "30 FPS": "30",
                    "60 FPS": "60",
                    "120 FPS": "120",
                },
            },
            {
                "key": "resolution",
                "label": "Resolution",
                "type": "choice",
                "choices": {
                    "Original": "original",
                    "480p": "480p",
                    "720p": "720p",
                    "1080p": "1080p",
                    "2160p (4K)": "2160p",
                },
            },
            {"key": "normalize_audio", "label": "Normalize Audio", "type": "toggle"},
            {"key": "overwrite", "label": "Overwrite Files", "type": "toggle"},
            {
                "key": "codec",
                "label": "Codec",
                "type": "toggle",
                "toggle_values": ["hevc", "h264"],
                "display_map": {"hevc": "HEVC", "h264": "H.264"},
            },
        ]

        final_settings = prompt_for_interactive_settings(
            settings_definitions=settings_definitions,
            current_settings=initial_settings,
            title="Conversion Settings",
        )

        if final_settings is None:
            raise typer.Abort()

        # --- Run Conversion(s) ---
        stats = ProcessingStats()
        estimator = BatchTimeEstimator()
        estimator.start()
        total_files = len(files_to_process)
        start_time = time.monotonic()

        async def run_conversion() -> None:
            # * Calculate total video duration for ETA
            console.print("[*] Calculating total video duration for ETA...")
            for fp in files_to_process:
                duration = await get_video_duration(str(fp))
                if duration:
                    estimator.add_item(duration)

            if estimator.total_workload > 0:
                console.print(
                    f"[*] Total video duration: {format_duration(estimator.total_workload)}"
                )

            for idx, file_path in enumerate(files_to_process, 1):
                try:
                    if output_file and total_files == 1:
                        out_dir = output_file.parent
                    else:
                        out_dir = (
                            output_dir if output_file is None else output_file.parent
                        )
                    await _process_single_file_for_conversion(
                        file_path=file_path,
                        output_dir=out_dir,
                        quality=final_settings["quality"],
                        fps=final_settings["fps"],
                        resolution=final_settings["resolution"],
                        normalize_audio=final_settings["normalize_audio"],
                        overwrite=final_settings["overwrite"],
                        codec=final_settings["codec"],
                        stats=stats,
                        estimator=estimator,
                        position=idx,
                        total=total_files,
                        use_original_name=False,
                    )
                    # If single file and custom output name, rename result
                    if output_file and total_files == 1:
                        default_output = (
                            output_file.parent / f"{file_path.stem}_converted.mp4"
                        )
                        if default_output.exists() and default_output != output_file:
                            shutil.move(str(default_output), str(output_file))
                except Exception as e:
                    console.print(
                        f"[yellow]! Skipped file due to error: {file_path} ({e})[/yellow]"
                    )
                    stats.increment("skipped")

        try:
            asyncio.run(run_conversion())
        except KeyboardInterrupt:
            console.print(
                "\n[yellow]! User interrupted the process. Shutting down...[/yellow]"
            )
            # ! Show statistics before termination
            elapsed_time = time.monotonic() - start_time
            console.print("\n--- Interrupted Process Summary ---")
            stats.print_summary(elapsed_time)
        except asyncio.CancelledError:
            console.print(
                "\n[yellow]! Process was cancelled. Shutting down...[/yellow]"
            )
            # ! Show statistics before termination
            elapsed_time = time.monotonic() - start_time
            console.print("\n--- Cancelled Process Summary ---")
            stats.print_summary(elapsed_time)

        elapsed_time = time.monotonic() - start_time
        stats.print_summary(elapsed_time)
        console.print("[green]✓ Conversion complete.[/green]")

    except typer.Abort:
        console.print("\n[yellow]! Operation cancelled by user.[/yellow]")
    except KeyboardInterrupt:
        console.print("\n[yellow]! Operation cancelled by user.[/yellow]")


@app.command()
def tree() -> None:  # noqa: C901
    """
    Recursively convert all videos in a directory tree, preserving the structure.
    """
    console.print("[*] Interactive directory tree conversion.")

    try:
        # --- Input Directory ---
        while True:
            input_str = typer.prompt(
                "Enter the absolute path to the root directory to convert"
            )
            input_dir = Path(input_str.strip().strip('"'))
            if input_dir.is_dir():
                break
            console.print(
                f"[red]! Directory not found or not a directory: {input_dir}. Please try again.[/red]"
            )

        # --- Output Directory ---
        output_str = typer.prompt(
            "Enter the absolute path for the output directory (or press Enter for default)",
            default=str(OUTPUT_DIR.resolve()),
        )
        output_dir = Path(output_str.strip().strip('"'))
        ensure_dir_exists(output_dir)

        # --- Scan for files ---
        console.print("[*] Scanning for files in the source directory...")
        all_files = [p for p in input_dir.rglob("*") if p.is_file()]
        supported_extensions = [".mp4", ".mkv", ".mov", ".avi", ".webm"]

        video_files_to_process = [
            p for p in all_files if p.suffix.lower() in supported_extensions
        ]
        other_files_to_copy = [
            p for p in all_files if p.suffix.lower() not in supported_extensions
        ]

        # --- Exit if no files to process ---
        if not video_files_to_process and not other_files_to_copy:
            console.print("[yellow]! No files found in the source directory.[/yellow]")
            raise typer.Exit()

        console.print(f"[*] Found {len(video_files_to_process)} video(s) to convert.")

        # --- Interactive Settings Menu ---
        initial_settings = {
            "quality": "26",
            "fps": "original",
            "resolution": "original",
            "codec": "hevc",
            "normalize_audio": False,
            "overwrite": False,
        }

        settings_definitions: List[Dict[str, Any]] = [
            {
                "key": "quality",
                "label": "Quality",
                "type": "choice",
                "choices": {
                    "Master (CQ=26)": "26",
                    "Optimal (CQ=30)": "30",
                    "Compact (CQ=34)": "34",
                    "Compressed (CQ=40, <=720p)": "40",
                },
            },
            {
                "key": "fps",
                "label": "FPS",
                "type": "choice",
                "choices": {
                    "Original": "original",
                    "30 FPS": "30",
                    "60 FPS": "60",
                    "120 FPS": "120",
                },
            },
            {
                "key": "resolution",
                "label": "Resolution",
                "type": "choice",
                "choices": {
                    "Original": "original",
                    "480p": "480p",
                    "720p": "720p",
                    "1080p": "1080p",
                    "2160p (4K)": "2160p",
                },
            },
            {"key": "normalize_audio", "label": "Normalize Audio", "type": "toggle"},
            {"key": "overwrite", "label": "Overwrite Files", "type": "toggle"},
            {
                "key": "codec",
                "label": "Codec",
                "type": "toggle",
                "toggle_values": ["hevc", "h264"],
                "display_map": {"hevc": "HEVC", "h264": "H.264"},
            },
        ]

        final_settings = prompt_for_interactive_settings(
            settings_definitions=settings_definitions,
            current_settings=initial_settings,
            title="Conversion Settings",
        )

        if final_settings is None:
            raise typer.Abort()

        # --- Run Operations ---
        stats = ProcessingStats()
        # * Filter out existing videos if overwrite disabled
        if not final_settings["overwrite"]:
            filtered_videos: List[Path] = []
            for file_path in video_files_to_process:
                relative_path = file_path.relative_to(input_dir)
                dest_path = output_dir / relative_path
                if dest_path.exists():
                    console.print(f"  -> Skipped (exists): {relative_path}")
                    stats.increment("skipped")
                else:
                    filtered_videos.append(file_path)
            video_files_to_process = filtered_videos
        stats.stats["total"] = len(video_files_to_process)
        estimator = BatchTimeEstimator()
        stop_event = asyncio.Event()
        start_time = time.monotonic()

        # --- Copy non-video files first ---
        if other_files_to_copy:
            console.print("\n[*] Copying non-video files...")
            for file_path in other_files_to_copy:
                # ! Check for interruption during file copying
                if stop_event.is_set():
                    console.print("[yellow]! File copying interrupted.[/yellow]")
                    break

                relative_path = file_path.relative_to(input_dir)
                destination_path = output_dir / relative_path

                if not final_settings["overwrite"] and destination_path.exists():
                    console.print(f"  -> Skipped (exists): {relative_path}")
                    stats.increment("skipped_copy")
                    continue

                try:
                    ensure_dir_exists(destination_path.parent)
                    shutil.copy2(file_path, destination_path)
                    console.print(f"  -> Copied: {relative_path}")
                    stats.increment("copied")
                except Exception as e:
                    console.print(f"  [red]! Failed to copy {relative_path}: {e}[/red]")
                    stats.increment("copy_errors")

        async def main_async_logic() -> None:
            # --- Estimate time ---
            if video_files_to_process:
                console.print("\n[*] Calculating total video duration for ETA...")
                for file_path in video_files_to_process:
                    # ! Check for interruption during duration calculation
                    if stop_event.is_set():
                        console.print(
                            "[yellow]! Duration calculation interrupted.[/yellow]"
                        )
                        return

                    duration = await get_video_duration(str(file_path))
                    if duration:
                        estimator.add_item(duration)

                if estimator.total_workload > 0:
                    console.print(
                        f"[*] Total video duration: {format_duration(estimator.total_workload)}"
                    )

                estimator.start()

                # --- Run Conversions ---
                console.print("\n[*] Starting video conversions...")

                # Prepare tasks with quality fallback: if output larger than input, retry with lower quality
                async def process_with_fallback(
                    file_path: Path,
                    out_dir: Path,
                    position: int,
                    total: int,
                ) -> None:
                    # Define quality order (higher CQ => lower quality)
                    quality_order = ["26", "30", "34", "40"]
                    # Start from user-selected quality
                    try:
                        start_idx = quality_order.index(final_settings["quality"])
                    except ValueError:
                        start_idx = 0
                    input_size = file_path.stat().st_size
                    # * Capture video duration for ETA and fallback revert
                    video_duration = await get_video_duration(str(file_path)) or 0
                    for q in quality_order[start_idx:]:
                        # Convert with quality q
                        await _process_single_file_for_conversion(
                            file_path=file_path,
                            output_dir=out_dir,
                            quality=q,
                            fps=final_settings["fps"],
                            resolution=final_settings["resolution"],
                            normalize_audio=final_settings["normalize_audio"],
                            overwrite=final_settings["overwrite"],
                            codec=final_settings["codec"],
                            stats=stats,
                            estimator=estimator,
                            position=position,
                            total=total,
                            use_original_name=True,
                        )
                        # Compare sizes using original filename
                        output_path = out_dir / file_path.name
                        if output_path.exists():
                            output_size = output_path.stat().st_size
                            if output_size <= input_size:
                                break  # acceptable size
                            # retry with next quality level
                            console.print(
                                f"  [yellow]! Output larger than input, retrying with lower quality CQ={q}"
                            )
                            # * Revert previous conversion count and ETA estimation before retry
                            if video_duration:
                                estimator.workload_processed -= video_duration
                                estimator.items_processed -= 1
                            stats.stats["processed"] -= 1
                            # remove previous oversized file
                            safe_delete(output_path)
                        else:
                            break

                tasks: List[Coroutine[Any, Any, None]] = []
                for idx, file_path in enumerate(video_files_to_process, 1):
                    relative_path = file_path.relative_to(input_dir)
                    out_dir_for_file = output_dir / relative_path.parent
                    ensure_dir_exists(out_dir_for_file)
                    tasks.append(
                        process_with_fallback(
                            file_path=file_path,
                            out_dir=out_dir_for_file,
                            position=idx,
                            total=len(video_files_to_process),
                        )
                    )

                concurrency = (
                    1  # ! Sequential processing to avoid GPU resource conflicts
                )
                await run_tasks_with_semaphore(tasks, stop_event, concurrency)

        # ! Setup signal handler for graceful interruption
        def signal_handler() -> None:
            console.print("\n[yellow]! Interruption signal received...[/yellow]")
            stop_event.set()

        # ! Register signal handler before starting async operations
        import signal

        original_handler = signal.signal(signal.SIGINT, lambda s, f: signal_handler())

        try:
            asyncio.run(main_async_logic())
        except KeyboardInterrupt:
            console.print(
                "\n[yellow]! User interrupted the process. Shutting down...[/yellow]"
            )
            stop_event.set()
            # ! Show statistics before termination
            elapsed_time = time.monotonic() - start_time
            console.print("\n--- Interrupted Process Summary ---")
            stats.print_summary(elapsed_time)
        except asyncio.CancelledError:
            console.print(
                "\n[yellow]! Process was cancelled. Shutting down...[/yellow]"
            )
            stop_event.set()
            # ! Show statistics before termination
            elapsed_time = time.monotonic() - start_time
            console.print("\n--- Cancelled Process Summary ---")
            stats.print_summary(elapsed_time)
        finally:
            # ! Restore original signal handler
            signal.signal(signal.SIGINT, original_handler)

        elapsed_time = time.monotonic() - start_time
        stats.print_summary(elapsed_time)

        console.print("[green]✓ Tree processing complete.[/green]")

    except (typer.Abort, KeyboardInterrupt):
        console.print("\n[yellow]! Operation cancelled by user.[/yellow]")


async def _convert_single_file_for_merge(
    file_path: Path,
    temp_dir: Path,
    quality: str,
    fps: str,
    resolution: str,
    normalize_audio: bool,
    codec: str,
    stats: ProcessingStats,
    estimator: BatchTimeEstimator,
    position: int,
    total: int,
) -> Optional[Path]:
    """Helper to convert one file for merging."""
    converted_path = temp_dir / f"{position:03d}_{file_path.stem}_converted.mp4"
    eta_str = estimator.get_eta_str()
    console.print(
        f"[{position}/{total}] Converting {file_path.name} for merge | ETA: {eta_str}"
    )

    total_duration = await get_video_duration(str(file_path))

    filters: List[str] = []
    if resolution != "original":
        res_map = {"480p": 480, "720p": 720, "1080p": 1080, "2160p": 2160}
        target_height = res_map.get(resolution)
        if target_height:
            original_res = await get_video_resolution(str(file_path))
            if original_res and original_res[1] > target_height:
                filters.append(f"scale=-2:{target_height}:flags=lanczos")

    if fps != "original":
        filters.append(f"fps={fps}")

    # * For H.264, force 8-bit pixel format to avoid errors with 10-bit sources on consumer GPUs.
    if codec == "h264":
        filters.append("format=yuv420p")

    video_cmd = get_nvenc_video_options(codec=codec, quality=quality)
    if filters:
        video_cmd.extend(["-vf", ",".join(filters)])

    audio_cmd = (
        ["-c:a", "aac", "-b:a", "192k", "-af", "loudnorm=I=-16:TP=-3:LRA=11"]
        if normalize_audio
        else ["-c:a", "copy"]
    )

    cmd = (
        ["ffmpeg", "-y", "-i", str(file_path)]
        + video_cmd
        + audio_cmd
        + [str(converted_path)]
    )

    success = await run_ffmpeg_command(
        cmd,
        stats=stats,
        quiet=True,
        output_path=str(converted_path),
        file_position=position,
        file_count=total,
        filename=file_path.name,
        total_duration=total_duration,
    )

    if success:
        console.print(f"  [green]✓ Converted:[/green] {converted_path.name}")
        if total_duration:
            estimator.update(total_duration)
        return converted_path

    console.print(f"  [red]✗ Conversion failed:[/red] {file_path.name}")
    return None


@app.command()
def merge(  # noqa: C901
    inputs: Annotated[
        List[Path],
        typer.Option(
            "--input",
            "-i",
            help="Input video file. Provide this option multiple times for each file in order.",
        ),
    ],
    output: Annotated[
        Path,
        typer.Option("--output", "-o", help="Output file path for the merged video."),
    ],
    quality: Annotated[
        str, typer.Option(help="Encoding quality for intermediate files. [26|30|34|40]")
    ] = "26",
    fps: Annotated[
        str,
        typer.Option(help="Target FPS for intermediate files. [original|30|60|120]"),
    ] = "original",
    resolution: Annotated[
        str,
        typer.Option(
            help="Target resolution for intermediate files. [original|480p|720p|1080p|2160p]"
        ),
    ] = "original",
    codec: Annotated[
        str, typer.Option(help="Video codec for intermediate conversion. [hevc|h264]")
    ] = "hevc",
    normalize_audio: Annotated[
        bool, typer.Option(help="Normalize audio during intermediate conversion.")
    ] = False,
    cleanup: Annotated[
        bool,
        typer.Option(
            "--cleanup-source", help="Delete source files upon successful merge."
        ),
    ] = False,
) -> None:
    """
    Convert multiple videos (to HEVC/H.264) and merge them into one.
    """
    if len(inputs) < 2:
        console.print("[red]! Merge command requires at least two input files.[/red]")
        raise typer.Exit(code=1)

    console.print(f"[*] Starting merge for {len(inputs)} video files.")
    ensure_dir_exists(output.parent)

    temp_dir = output.parent / f"__merge_temp_{os.getpid()}__"
    ensure_dir_exists(temp_dir)

    stats = ProcessingStats()
    estimator = BatchTimeEstimator()
    converted_files: List[Path] = []
    merge_success = False
    start_time = time.monotonic()  # ! Track start time for interruption statistics

    try:

        async def merge_async_logic() -> bool:
            console.print("[*] Calculating total duration for ETA...")
            for file_path in inputs:
                duration = await get_video_duration(str(file_path))
                if duration:
                    estimator.add_item(duration)

            if estimator.total_workload > 0:
                console.print(
                    f"[*] Total video duration: {format_duration(estimator.total_workload)}"
                )

            estimator.start()

            for i, file_path in enumerate(inputs):
                result_path = await _convert_single_file_for_merge(
                    file_path,
                    temp_dir,
                    quality,
                    fps,
                    resolution,
                    normalize_audio,
                    codec,
                    stats,
                    estimator,
                    i + 1,
                    len(inputs),
                )
                if not result_path:
                    raise RuntimeError(
                        f"Failed to convert {file_path.name}, aborting merge."
                    )
                converted_files.append(result_path)

            # Create concat list file
            concat_list_path = temp_dir / "concat_list.txt"
            with concat_list_path.open("w", encoding="utf-8") as f:
                for p in converted_files:
                    f.write(f"file '{p.resolve().as_posix()}'\n")

            console.print("\n[*] Merging converted videos...")
            merge_cmd = [
                "ffmpeg",
                "-y",
                "-f",
                "concat",
                "-safe",
                "0",
                "-i",
                str(concat_list_path),
                "-c",
                "copy",
                str(output),
            ]
            process = subprocess.run(merge_cmd, capture_output=True, text=True)

            if process.returncode == 0:
                return True

            console.print("[red]! Merge operation failed. FFmpeg output:[/red]")
            console.print(process.stderr)
            return False

        merge_success = asyncio.run(merge_async_logic())

    except KeyboardInterrupt:
        console.print("\n[yellow]! User interrupted the process.[/yellow]")
        # ! Show statistics before termination
        elapsed_time = time.monotonic() - start_time
        console.print("\n--- Interrupted Process Summary ---")
        stats.print_summary(elapsed_time)
    except Exception as e:
        console.print(f"\n[red]! An error occurred during merge: {e}[/red]")
        # ! Show statistics before termination
        elapsed_time = time.monotonic() - start_time
        console.print("\n--- Error Process Summary ---")
        stats.print_summary(elapsed_time)
    finally:
        if temp_dir.exists():
            console.print("[*] Cleaning up temporary files...")
            shutil.rmtree(temp_dir, ignore_errors=True)

    if merge_success:
        console.print(f"\n[green]✓ Merge successful![/green] Output: {output}")
        if cleanup:
            console.print("[*] Deleting source files as requested...")
            for file_path in inputs:
                if safe_delete(file_path):
                    console.print(f"  - Deleted: {file_path.name}")
    else:
        console.print("\n[red]✗ Merge process failed or was interrupted.[/red]")

    elapsed_time = time.monotonic() - start_time
    stats.print_summary(elapsed_time)


@app.command()
def compile(
    inputs: Annotated[
        List[Path],
        typer.Option(
            "--input",
            "-i",
            help="Input files. First is video source. Provide option multiple times.",
        ),
    ],
    output_dir: Annotated[
        Path,
        typer.Option("--output", "-o", help="Output directory for the compiled file."),
    ] = OUTPUT_DIR,
    keep_original_audio: Annotated[
        bool, typer.Option(help="Keep audio from the primary video source file.")
    ] = False,
    keep_original_subtitles: Annotated[
        bool, typer.Option(help="Keep subtitles from the primary video source file.")
    ] = False,
    output_container: Annotated[
        str, typer.Option(help="Container for the output file. [mkv|mp4]")
    ] = "mkv",
    overwrite: Annotated[
        bool, typer.Option(help="Overwrite existing file in the output directory.")
    ] = False,
) -> None:
    """
    Compile a video from multiple sources (video, audio, subtitles).
    """
    if not inputs:
        console.print("[red]! Compile command requires at least one input file.[/red]")
        raise typer.Exit(code=1)

    primary_input = inputs[0]
    output_filename = f"{primary_input.stem}_compiled.{output_container}"
    output_path = output_dir / output_filename

    ensure_dir_exists(output_dir)
    console.print(f"[*] Compiling from '{primary_input.name}' to '{output_path.name}'.")

    if not overwrite and output_path.exists():
        console.print(f"[yellow]! Skipped (exists): {output_path.name}[/yellow]")
        raise typer.Exit()

    # --- Assemble FFmpeg command ---
    cmd = ["ffmpeg", "-y"]
    for file_path in inputs:
        cmd.extend(["-i", str(file_path)])

    # --- Mapping ---
    cmd.extend(["-map", "0:v:0?"])  # Map primary video stream, if it exists
    if keep_original_audio:
        cmd.extend(["-map", "0:a?"])
    for i in range(1, len(inputs)):
        cmd.extend(["-map", f"{i}:a?"])
    if keep_original_subtitles:
        cmd.extend(["-map", "0:s?"])
    for i in range(1, len(inputs)):
        cmd.extend(["-map", f"{i}:s?"])

    # --- Codecs ---
    if output_container == "mp4":
        console.print(
            "[*] MP4 output selected. Subtitles will be converted to 'mov_text'."
        )
        cmd.extend(["-c:v", "copy", "-c:a", "copy", "-c:s", "mov_text"])
    else:
        cmd.extend(["-c", "copy"])

    cmd.append(str(output_path))

    stats = ProcessingStats()
    stats.stats["total"] = 1
    start_time = time.monotonic()  # ! Track start time for interruption statistics

    async def do_compile() -> None:
        total_duration = await get_video_duration(str(primary_input))
        success = await run_ffmpeg_command(
            cmd,
            stats=stats,
            quiet=True,
            output_path=str(output_path),
            file_position=1,
            file_count=1,
            filename=output_filename,
            total_duration=total_duration,
        )
        if success:
            console.print(
                f"  [green]✓ Success:[/green] Compilation finished -> {output_path.name}"
            )
        else:
            console.print(
                f"  [red]✗ Failed:[/red] {primary_input.name}. Check FFmpeg output for details."
            )
            console.print(
                f"  [yellow]! Tip:[/yellow] The '{output_container}' container might not support all codecs from the input files. Try 'mkv'."
            )
            safe_delete(output_path)

    try:
        asyncio.run(do_compile())
    except KeyboardInterrupt:
        console.print("\n[yellow]! User interrupted the process.[/yellow]")
        # ! Show statistics before termination
        elapsed_time = time.monotonic() - start_time
        console.print("\n--- Interrupted Process Summary ---")
        stats.print_summary(elapsed_time)
    except Exception as e:
        stats.increment("errors")
        console.print(
            f"  [red]✗ Exception while compiling {primary_input.name}: {e}[/red]"
        )
        safe_delete(output_path)
        # ! Show statistics before termination
        elapsed_time = time.monotonic() - start_time
        console.print("\n--- Error Process Summary ---")
        stats.print_summary(elapsed_time)

    elapsed_time = time.monotonic() - start_time
    stats.print_summary(elapsed_time)


if __name__ == "__main__":
    setup_signal_handler()  # * For graceful Ctrl+C handling
    app()
